:ref_current: https://www.elastic.co/guide/en/elasticsearch/reference/current

:github: https://github.com/elastic/elasticsearch-net

:nuget: https://www.nuget.org/packages

[[skip-dead-nodes]]
== Skip Dead Nodes

Sticky - Skipping Dead Nodes
When selecting nodes the connection pool will try and skip all the nodes that are marked dead.

[source,csharp]
----
var seeds = Enumerable.Range(9200, NumberOfNodes).Select(p => new Node(new Uri("http://localhost:" + p))).ToList();

seeds.First().MarkDead(DateTime.Now.AddDays(1));

var pool = new StickyConnectionPool(seeds);

var node = pool.CreateView().First();

node.Uri.Port.Should().Be(9201);

node = pool.CreateView().First();

node.Uri.Port.Should().Be(9201);
----

[source,csharp]
----
var seeds = Enumerable.Range(9200, NumberOfNodes).Select(p => new Node(new Uri("http://localhost:" + p))).ToList();
var pool = new StickyConnectionPool(seeds);
var node = pool.CreateView().First();
node.Uri.Port.Should().Be(9200);
node = pool.CreateView().First();
node.Uri.Port.Should().Be(9200);
node = pool.CreateView().First();
node.Uri.Port.Should().Be(9200);
----

After we marke the first node alive again we expect it to be hit again

[source,csharp]
----
seeds.First().MarkAlive();

var node = pool.CreateView().First();

node.Uri.Port.Should().Be(9200);

node = pool.CreateView().First();

node.Uri.Port.Should().Be(9200);

node = pool.CreateView().First();

node.Uri.Port.Should().Be(9200);
----

[source,csharp]
----
var dateTimeProvider = new TestableDateTimeProvider();

var seeds = Enumerable.Range(9200, NumberOfNodes).Select(p => new Node(new Uri("http://localhost:" + p))).ToList();

seeds.First().MarkDead(dateTimeProvider.Now().AddDays(1));

var pool = new StickyConnectionPool(seeds, dateTimeProvider: dateTimeProvider);

var node = pool.CreateView().First();

node.Uri.Port.Should().Be(9201);

node = pool.CreateView().First();

node.Uri.Port.Should().Be(9201);
----

If we forward our clock 2 days the node that was marked dead until tomorrow (or yesterday!) should be resurrected 

[source,csharp]
----
dateTimeProvider.ChangeTime(d => d.AddDays(2));

var n = pool.CreateView().First();

n.Uri.Port.Should().Be(9200);

n = pool.CreateView().First();

n.Uri.Port.Should().Be(9200);

n = pool.CreateView().First();

n.Uri.Port.Should().Be(9200);

n.IsResurrected.Should().BeTrue();
----

A cluster with 2 nodes where the second node fails on ping 

[source,csharp]
----
var audit = new Auditor(() => Framework.Cluster
    .Nodes(4)
    .ClientCalls(p => p.Succeeds(Always))
    .ClientCalls(p => p.OnPort(9200).FailAlways())
    .ClientCalls(p => p.OnPort(9201).FailAlways())
    .StickyConnectionPool()
    .Settings(p => p.DisablePing())
);
----

The first call goes to 9200 which succeeds 

The 2nd call does a ping on 9201 because its used for the first time.
It fails so we wrap over to node 9202 

Finally we assert that the connectionpool has one node that is marked as dead 

[source,csharp]
----
await audit.TraceCalls(
new ClientCall {
        { BadResponse, 9200},
        { BadResponse, 9201},
        { HealthyResponse, 9202},
        { pool => pool.Nodes.Where(n=>!n.IsAlive).Should().HaveCount(2) }
    },
new ClientCall {
        { HealthyResponse, 9202},
{ pool =>  pool.Nodes.Where(n=>!n.IsAlive).Should().HaveCount(2) }
    },
    new ClientCall {
        { HealthyResponse, 9202},
        { pool => pool.Nodes.Where(n=>!n.IsAlive).Should().HaveCount(2) }
    }
);
----

A cluster with 2 nodes where the second node fails on ping 

[source,csharp]
----
var audit = new Auditor(() => Framework.Cluster
    .Nodes(4)
    .ClientCalls(p => p.Fails(Always))
    .StickyConnectionPool()
    .Settings(p => p.DisablePing())
);
----

All the calls fail 

After all our registered nodes are marked dead we want to sample a single dead node
each time to quickly see if the cluster is back up. We do not want to retry all 4
nodes

[source,csharp]
----
await audit.TraceCalls(
new ClientCall {
        { BadResponse, 9200},
        { BadResponse, 9201},
        { BadResponse, 9202},
        { BadResponse, 9203},
        { MaxRetriesReached },
        { pool => pool.Nodes.Where(n=>!n.IsAlive).Should().HaveCount(4) }
    },
new ClientCall {
        { AllNodesDead },
        { Resurrection, 9200},
        { BadResponse, 9200},
        { pool =>  pool.Nodes.Where(n=>!n.IsAlive).Should().HaveCount(4) }
    },
    new ClientCall {
        { AllNodesDead },
        { Resurrection, 9201},
        { BadResponse, 9201},
        { pool =>  pool.Nodes.Where(n=>!n.IsAlive).Should().HaveCount(4) }
    },
    new ClientCall {
        { AllNodesDead },
        { Resurrection, 9202},
        { BadResponse, 9202},
        { pool =>  pool.Nodes.Where(n=>!n.IsAlive).Should().HaveCount(4) }
    },
    new ClientCall {
        { AllNodesDead },
        { Resurrection, 9203},
        { BadResponse, 9203},
        { pool =>  pool.Nodes.Where(n=>!n.IsAlive).Should().HaveCount(4) }
    }
);
----

